#if false


	NOTE:	This class is currently unused in fsrlib


#define	Experiment1	// remove all parameters not set by FSRConverterFromNMEA
#define	Experiment5	// Shift timeval and abstime to known starting point
//#define	Experiment4	// set "ticks" value to 0 in data frames
//#define	Experiment3	// Shift abstime to known starting point
//#define	Experiment2	// set both "ticks" and "timestamp" values to 0 in data frames


/*

	FSRWriterFilter.cs - Diagnostic FSRWriter filter
    Copyright (C) 2003, Marty Ross


	Allows for selective filtering of FSR data written.

	Current form of this class supports several different experimental filter components
	to help diagnose problem of synchronizing to video time in simulator.  Since problem
	was found, this module is deprecated and not currently useful.

*/


using System ;

namespace fsrlib
{

	public class FSRWriterFilter : FSRWriter
	{

		public FSRWriterFilter(FSRWriter writer)
		{
			m_writer= writer ;
		}

		public override FSRWriter.Chunk Start()
		{
			return(m_writer.Start()) ;
		}

		public override void End(FSRWriter.Chunk startChunk)
		{
			m_writer.End(startChunk) ;
		}

		public override FSRWriter.Chunk FsibStart()
		{
			return(m_writer.FsibStart()) ;
		}

		public override void FsibEnd(FSRWriter.Chunk startChunk)
		{
			m_writer.FsibEnd(startChunk) ;
		}

		public override FSRWriter.Chunk FsibBfibStart()
		{
			return(m_writer.FsibBfibStart()) ;
		}

		public override void FsibBfibEnd(FSRWriter.Chunk bfibChunk)
		{
			m_writer.FsibBfibEnd(bfibChunk) ;
		}

		public override FSRWriter.Chunk FsibBfibOdibStart()
		{
			return(m_writer.FsibBfibOdibStart()) ;
		}

		public override void FsibBfibOdibObItem(ushort oid, string oname)
		{
			m_writer.FsibBfibOdibObItem(oid, oname) ;
		}

		public override void FsibBfibOdibEnd(FSRWriter.Chunk bfibodibChunk)
		{
			m_writer.FsibBfibOdibEnd(bfibodibChunk) ;
		}

		public override FSRWriter.Chunk FsibBfibPdibStart()
		{
			return(m_writer.FsibBfibPdibStart()) ;
		}

		public override void FsibBfibPdibPrItem(
			ushort oid,
			ushort pid,
			ushort tid,
			string punits,
			string pname
		) {
			m_writer.FsibBfibPdibPrItem(oid, pid, tid, punits, pname) ;
		}

		public override void FsibBfibPdibEnd(FSRWriter.Chunk bfibpdibChunk)
		{
			m_writer.FsibBfibPdibEnd(bfibpdibChunk) ;
		}

		public override FSRWriter.Chunk FsibBfibFribStart()
		{
			return(m_writer.FsibBfibFribStart()) ;
		}

		public override void FsibBfibFribTsItem(uint frno, uint ticks, long timeval)
		{
#if	Experiment2
			//
			//	Experiment:	Set ticks & timeval to zero
			//	Hypothesis:	This will have effect on time synchronization.
			//	Result:		True - prevents time synchronization (flys fast)
			//	Conclusion:	Time "seems" to be set from ABSTIME values (must verify).
			//
			ticks= 0 ;
			timeval= 0 ;
#endif
#if	Experiment4
			//
			//	Experiment:	Set ticks (only) to zero
			//	Hypothesis:	This will have effect on time synchronization.
			//	Result:		(1) with Experiment3, nothing happens
			//			(2) without Experiment3, works OK
			//	Conclusion:	In light of results from this experiment (and the
			//			interactions with Experiment2 and Experiment3),
			//			it appears that "timeval" is used for sequencing
			//			and that there is a mandatory relationship between
			//			the "timeval" values and the "abstime" values.
			//			Furthermore, ticks doesn't seem to matter at all.
			//
			ticks= 0 ;
#endif
#if	Experiment5
			//
			//	Experiment:	Shift both "timeval" and "abstime" down to known starting time.
			//	Hypothesis:	Relationship is fixed multiple (256.0) between these values.
			//	Results:	Works OK
			//	Conclusion:	Shifting both values together, enforcing this fixed-ratio
			//			relationship appears to be successful, implying that it is
			//			the correct relationship.  Simulator appears to set the date
			//			from "abstime", and appears to sequence properly by "timeval".
			//
			if (m_oldstartsecs == 0) {
				m_oldstartsecs= ((double) timeval / 256.0) ;
			}
			timeval-= (long) (m_oldstartsecs * 256.0) ;
			timeval+= (long) (m_newstartsecs * 256.0) ;
#endif
			m_writer.FsibBfibFribTsItem(frno, ticks, timeval) ;
		}

		public override void FsibBfibFribFrItem(ushort oid, ushort pid, ushort tid, Object o)
		{
#if	Experiment1
			//
			//	Experiment:	Remove all parameters not generated by GPS converter.
			//	Hypothesis:	One of these parameters missing causes time problem.
			//	Result:		False - time problem not exhibited on filtered FS recording.
			//
			if (
				(pid != (ushort) FSRPropertyId.PLANE_LATITUDE)
			     &&	(pid != (ushort) FSRPropertyId.PLANE_LONGITUDE)
			     &&	(pid != (ushort) FSRPropertyId.PLANE_ALTITUDE)
			     &&	(pid != (ushort) FSRPropertyId.PLANE_PITCH_DEGREES)
			     &&	(pid != (ushort) FSRPropertyId.PLANE_BANK_DEGREES)
			     &&	(pid != (ushort) FSRPropertyId.PLANE_HEADING_DEGREES_TRUE)
			     &&	(pid != (ushort) FSRPropertyId.INDICATED_ALTITUDE)
			     &&	(pid != (ushort) FSRPropertyId.AIRSPEED_INDICATED)
			     &&	(pid != (ushort) FSRPropertyId.PLANE_HEADING_DEGREES_MAGNETIC)
			     &&	(pid != (ushort) FSRPropertyId.G_FORCE)
			     &&	(pid != (ushort) FSRPropertyId.ABSOLUTE_TIME)
			     &&	(pid != (ushort) FSRPropertyId.PLANE_BANK_DEGREES)
			     &&	(pid != (ushort) FSRPropertyId.TIME_ZONE_OFFSET)
			) {
				Logger.LogNote("FSRWriterFilter: deleted pid=" + pid) ;
				return ;
			}
#endif

#if	Experiment3
			//
			//	Experiment:	Shift video time to known starting time.
			//	Hypothesis:	Simulator is not looking at video time.
			//	Result:		False - simulator definitely sets sim time to video time.
			//			(even though ticks and timeval is 0 due to Experiment2)
			//
			if (pid == (ushort) FSRPropertyId.ABSOLUTE_TIME) {
				double secs= (double) o ;
				if (m_oldstartsecs == 0) {
					m_oldstartsecs= secs ;
				}
				secs-= m_oldstartsecs ;
				secs+= m_newstartsecs ;
				o= secs ;
			}
#endif

#if	Experiment5
			// see "Experiment5", above
			if (pid == (ushort) FSRPropertyId.ABSOLUTE_TIME) {
				double secs= (double) o ;
				secs-= m_oldstartsecs ;
				secs+= m_newstartsecs ;
				o= secs ;
			}
#endif

			m_writer.FsibBfibFribFrItem(oid, pid, tid, o) ;
		}

		public override void FsibBfibFribEnd(FSRWriter.Chunk bfibfribChunk)
		{
			m_writer.FsibBfibFribEnd(bfibfribChunk) ;
		}

		public override FSRWriter.Chunk FsibTrailerStart()
		{
			return(m_writer.FsibTrailerStart()) ;
		}

		public override void FsibTrailerDaItem(ushort dtype, string dval)
		{
			m_writer.FsibTrailerDaItem(dtype, dval) ;
		}

		public override void FsibTrailerEnd(FSRWriter.Chunk trailerChunk)
		{
			m_writer.FsibTrailerEnd(trailerChunk) ;
		}


		//
		//
		//

		private FSRWriter m_writer ;
#if	Experiment3
		private double m_newstartsecs= ((new DateTime(2003, 1, 27, 9, 23, 12, 0)).Ticks / 10000000.0) ;
		private double m_oldstartsecs= 0 ;
#endif
#if	Experiment5
		// mutually incompatible with Experiment3
		private double m_newstartsecs= ((new DateTime(2003, 1, 27, 19, 3, 42, 0)).Ticks / 10000000.0) ;
		private double m_oldstartsecs= 0 ;
#endif

	}
}


#endif
